                             Reactive Programming - Using Rxjava
..............................................................................................

What is Reactive Programming?

Reactive Programming is one the Programming style to build distributed applications,User interface applications,Mobile Applications.

Reactive Programming is not new style rather, it is application of  many programming principles.
 -Object oriented Programming
 -Functional Style Programming
 -Event Driven Programming.

Reactive Programming is not a language,lib,Framework rather  it is set of standards and principles.

Reactive Programming principles can be used on any language/lib/framework which is called 
"Reactive-X"  - Reactive Extension.
.............................................................................................
History of Rx Programming:
.........................
At Microsoft Erik Meijer who created Reactive Programming ideas from "C#".

Core Ideas behind Reactive Programming :

Object:
  -setters - write
  -getters - read

getters
   -single value - scallar values -number,strings,booleans,object
   -iteralble value(many values) - array , collection-list,map,set


Iterations:
 IEnumerable ,IEnumerator 

IEnumerator 
   - bridge interface which is used to iterate collection

  Producer                             Consumer/subscriber Caller(requester)
  moveNext():boolean -------------------->  give me a value /error

Based this we define programming model called "Pull based"

PULL Based Programming:
......................

List list =....

Iterator it=list.iterator()
while(it.hasNext()) {
   //pull data
 T data= it.next()
}

PULL Based Data Retrival

T data      - it.next() - Data 
T error     - throws Exception -  error
boolean done - !it.next()

Why PULL based programming not good?


 consumer pulls value from producer.
 consumer has control over producer.
 consumer only decide when he wants item.

             "Values are produced on demand by consumer"

Before a decade, programming model started like "Cloud based, async programming Programming" and distributed programming model - microservices.

MicroServices:

Program to Program interaction
Object(Caller) to Object(Callee) interaction

Pull Based Programming makes 

  -service tight coupling
  -blocking
  -failures
  
............................................................................................

PUSH Based Programming:
.......................

-Producer is sending data to COnsumer via events
-Producer notifies the consumer when ever data,error,complete events are given
-Push based programming is implemented based on "Observable Design Pattern"
-Observable Design pattern is foundatation pattern for "Event Driven Programming"

PUSH = {observable + Events Driven}
............................................................................................

As of now , we have seen how to stream Data based on events.
.............................................................................................

How to observe the stream? - Observation of Streams.

 Processing data streams.

Data Processing;
let say, i want list of employees who is working in onsite.

all employees are stored in database only. in order to get data, you have to write sql quries.

sql queries are executed on database engine and application finally gets reports.

//////////////////////////////////////////////////////////////////////////////////////////////////////
how to reduce sql query exection on database engine, how to add query features inside apps via language.
-Query language-SQL Like language- inside programming language.


  			    That is birth of LINQ

It is microsoft "Language-Integrated Query (LINQ)" is the name for a set of technologies based on the integration of query capabilities directly into the C# language.


                   // Specify the data source.
                 int[] scores = new int[] { 97, 92, 81, 60 };

        // Define the query expression.
      IEnumerable<int> scoreQuery = from score in scores  where score > 80  select score;

                    "select score from scores where score > 80" -SQL Query


Reactive Programming added new style of apis based functional programming principles

1.Pure function
   function never modifies data memory
2.immutablity
   create new copy of object every time
3.function composition
    chaining functions
4.Higher order Function
   function as parameter
4.declarative programming
   dont write much code , write less


1.Pure function;

Rules:

A.Pure function receives input, return the same to the caller.

  myfunction(a){
    return a; //no mutation /update on state
  }

 myfunction(10)

Side Effects:
 Pure function receives input, can compute its parameter and return result to the caller, but it should not do side effects.

  myfunction(a){
    return a + 10;
  }

 An operation, function or expression is said to have a side effect if it modifies some state variable value(s) outside its local environment,or inside local envirment.


  myfunction(a){
    return a + 10;
  }

you are changining /updating a's value - this is side effect- a is local variable.

you are changining /updating a's and b's value - this is side effect- a and b is local variable.


class myclass{
 int x=10;

 myfunction(){
    return x++;
  }
}
you are changining /updating x's value - this is side effect-x is state variable.

                         "Side effects create impure function"


Then how to change state/local variable?

B. Immutablity : To help function to be pure

immutablity:

   Immutable data structures cannot be modified after their creation/ updation.

When we change the data/state, you have to create new copy of state and return to the caller.


//////////////////////////////////////////////////////////////////////////////////////////////
				 Concurrency
..............................................................................................

Reactive Programming can be sync/async.

If async means.
ReactiveX is not biased toward some particular source of concurrency or asynchronicity. Observables can be implemented using thread-pools, event loops, non-blocking I/O apis(select,poll,epoll), actors (such as from Akka), or whatever implementation suits your needs, your style, or your expertise
.............................................................................................

Reactive programming =  { PUSH based,event driven,Observable  +  functional style apis + Declarative concurrency implementation }
.............................................................................................

Standards:

You need to understand reactive programming standards

->The Reactive Manifesto:https://www.reactivemanifesto.org/

   It is standard, published to build and ensure that system is fully reactive.


Principles of Best Reactive System:

1.Responsive:
   Reactive Systems should be responsive : Quick/Timely result.

2.Resilient:
   Any System is subject to fail, You must have failure work around.
   failures and how to fallback, provides high availability

3.Elastic : scalability
   In case of load, how to scale application by increasing and decreasing resources(Softwares)

4.Message Driven
   The Programs sends and receives data via events- event driven.

->Reactive Streams
.............................................................................................
How to start Reactive Programming?

 Reactive Programming can be implemented in any language.

implementations:
Java: RxJava
JavaScript: RxJS
C#: Rx.NET
C#(Unity): UniRx
Scala: RxScala
Clojure: RxClojure

JVM implementation:

1.RxJava
2.Project Reactor
3.Mutiny
.................................................................................................
					Rxjava
..............................................................................................

Project Setup:
.............
pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>Rxjavaapps</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
    </properties>
    <dependencies>
        <dependency>
            <groupId>io.reactivex.rxjava3</groupId>
            <artifactId>rxjava</artifactId>
            <version>3.0.5</version>
        </dependency>
    </dependencies>
</project>


Rx java Core concepts:

Stream:
......
 Data Stream;
        Flow of data from one place to another place


Publisher and Subscriber :
........................

  Both are objects. before sending data , we need to create those objects.

Publisher:
 You have to create Publisher Object only , through which we can get Subscriber object.

Publisher Type Objects:
.................

1.Observable
2.Subject
3.Single
4.Maybe
5.Completeable
6.Flowable


Subscriber Objects

1.Observer
2.Subscriber

Binding Object:

3.Subscription


Data Processing /Observation:
..............................

data processing done through apis - are called as operators.

Operators:
 Operators are methods in java /function which does some operation.

-Operators have been designed based on functional programming prinples
    -pure function,immutable,declarative,composable.

Operators:
are classified into various category
-create Stream
-tranformation
-filtering
-coimbing
-Error handling
-utility 
-conditional and boolean
-mathmetical and aggregate
-backpressue
-connectable
-converter
...........................................................................................

ote:

 If you want to create any objects, you have to use factory apis.


Create Publisher and Subscriber, subscribe , push data,error,complete into stream. listens for it.

package com.del.reactive.core;

import io.reactivex.rxjava3.core.Observable;

public class CreatePublisherSubscriber {
    public static void main(String[] args) {

        Observable<String> stream = Observable.create(observer -> {
            //push data.
            observer.onNext("Hello Reactive"); // streamming data
            observer.onNext("Welcome Reactive");
            observer.onNext("hai Reactive");
           // observer.onError(new RuntimeException("Something went wrong!!"));
            observer.onNext("greet Reactive");
            observer.onNext("how are you  Reactive");
            observer.onNext("what  about you Reactive");

            observer.onComplete(); // stream is closed
        });

        //Subscriber
        stream.subscribe(data -> {
            System.out.println(data);
        }, err -> {
            System.out.println(err);
        }, () -> System.out.println("done"));


        //stream.subscribe(System.out::println, System.out::println,
        //      () -> System.out.println("done"));
    }

}
.............................................................................................

Publisher object can created in many ways based on data sources.

Data Sources means from where we can get data and push it stream.

In Java Data sources are

1.primitive types
 strings,numbers,booleans,characters...

2.objects types
  employee,customer
3.Iterable
   array,list..
4.Future

Creational Operators:
.....................
create
defer
empty
error
from
generate
interval
just
never
range
timer

Marable Diagram:

 It is diagram, to represent flow of reactive apis.

                     items
 Publisher------------O-----O-----------------------------|----> Consumer
                                                      complete

-create :
  Used to create publisher and push items programmetically.

Operators which abstracts away like using sub.onNext(),sub.onComplete()

-just
   used to create publisher, for sequence of data.


package com.del.reactive.core.create;

import io.reactivex.rxjava3.core.Observable;

public class JustOperator {
    public static void main(String[] args) {
        Observable<Integer> intStream = Observable.just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        intStream.subscribe(System.out::println, System.out::println,
                () -> System.out.println("done"));
    }
}
...........................................................................................

Array as Data Source:
.....................
package com.del.reactive.core.create;

import io.reactivex.rxjava3.core.Observable;

class Employee {
    private int id;
    private String name;

    public Employee() {
    }

    public Employee(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Employee{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
}

public class ArrayOperator {
    public static void main(String[] args) {
        Integer[] items = {1, 2, 3, 4, 5, 6};
        Observable<Integer> stream = Observable.fromArray(items);
        stream.subscribe(System.out::println, System.out::println, () -> System.out.println("done"));

        Employee[] employees = {new Employee(1, "A"), new Employee(2, "B"), new Employee(3, "C")};
        Observable<Employee> empStream= Observable.fromArray(employees);
        empStream.subscribe(System.out::println, System.out::println, () -> System.out.println("done"));

    }
}
////////////////////////////////////////////////////////////////////////////////////////////

List as DataSource:
...................
package com.del.reactive.core.create;

import io.reactivex.rxjava3.core.Observable;

import java.util.Arrays;
import java.util.List;

public class ListOperator {
    public static void main(String[] args) {
        Integer[] items = {1, 2, 3, 4, 5, 6};
        List<Integer> list = Arrays.asList(items);
        Observable<Integer> stream = Observable.fromIterable(list);
        stream.subscribe(System.out::println, System.out::println, () -> System.out.println("done"));
    }
}
..............................................................................................

Callable to Observable:
........................
package com.del.reactive.core.create;

import io.reactivex.rxjava3.core.Observable;

import java.util.concurrent.Callable;

public class CallableOperator {
    public static void main(String[] args) {
        Callable<String> callable = () -> {
            System.out.println("Hello World!");
            return "Hello World!";
        };

        Observable<String> observable = Observable.fromCallable(callable);

        observable.subscribe(item -> System.out.println(item), error -> error.printStackTrace(),
                () -> System.out.println("Done"));
    }
}
...........................................................................................

generate : what if i want to emit sequence of values from 1 to 1000.


package com.del.reactive.core.create;

import io.reactivex.rxjava3.core.Observable;

public class GenerateOperator {
    public static void main(String[] args) {
        Observable<Integer> stream = Observable.range(1, 1000);
        stream.subscribe(System.out::println, System.out::println, () -> System.out.println("done"));
    }
}
...........................................................................................

defer operator is used to emit values based on some future values. Future values/async values
package com.del.reactive.core.create;

import io.reactivex.rxjava3.core.Observable;

public class DeferOperator {
    public static void main(String[] args) throws InterruptedException {
        Observable<String> observable = Observable.defer(() -> {
                 return Observable.just("hello");
        });

        observable.subscribe(time -> System.out.println(time));

        Thread.sleep(5000);

        observable.subscribe(time -> System.out.println(time));

    }
}
..............................................................................................

I dont want to send data,or error,only complete signal

empty

package com.del.reactive.core.create;

import io.reactivex.rxjava3.core.Observable;

public class EmptyOperator {
    public static void main(String[] args) {
        Observable stream = Observable.empty();
        stream.subscribe(System.out::println, System.out::println, () -> System.out.println("done"));

    }
}
..............................................................................................
I want to emit only error:
package com.del.reactive.core.create;

import io.reactivex.rxjava3.core.Observable;

public class ErrorOnlyOperator {
    public static void main(String[] args) {
        Observable<String> errorStream = Observable.error(new RuntimeException("Something went wrong"));
        errorStream.subscribe(System.out::println, System.out::println, () -> System.out.println("done"));

    }

}
............................................................................................

never:
This type of source does not signal any onNext, onSuccess, onError or onComplete. This type of reactive source is useful in testing or "disabling" certain sources in combinator operators.

package com.del.reactive.core.create;

import io.reactivex.rxjava3.core.Observable;

public class NeverOperator {
    public static void main(String[] args) {
        Observable<String> errorStream = Observable.never();
        errorStream.subscribe(System.out::println, System.out::println, () -> System.out.println("done"));

    }
}
............................................................................................

Timer:
Periodically generates an infinite, ever increasing numbers (of type Long). The intervalRange variant generates a limited amount of such numbers.

Range is also for generating sequence of numbers.

Timer-interval and range is where timer is infinite sequence number.


package com.del.reactive.core.create;

import io.reactivex.rxjava3.core.Observable;

import java.util.concurrent.TimeUnit;

public class TimerOperator {
    public static void main(String[] args) throws InterruptedException {
        
        //here streaming starts after 100ms ,that means data will be emitted only after 100ms only
        //before that main method got closed
        Observable<Long> timerStream = Observable.timer(1000, TimeUnit.MICROSECONDS);
        timerStream.subscribe(System.out::println, System.out::println, () -> System.out.println("done"));

        //Thread.sleep(5000);
        timerStream.blockingSubscribe(v -> System.out.println("Egg is ready!" + v));

    }
}
..............................................................................................

interval : for every 1ms/sec/hour/day , it starts emitting values.

if main process(main thread) has completed before emission, you dont see any values.
package com.del.reactive.core.create;

import io.reactivex.rxjava3.core.Observable;

import java.util.concurrent.TimeUnit;

public class IntervalOperator {
    public static void main(String[] args) throws InterruptedException {
        Observable<Long> clock = Observable.interval(1000, TimeUnit.MILLISECONDS);
        clock.subscribe(System.out::println, System.out::println,
                () -> System.out.println("done"));

       // Thread.sleep(5000);

    }
}

here we cant see any result. the reason is stream will emit data after 1000ms here, before that main thread closed.

Solution:

1.we can pause main thread for some time using Thread.sleep(howlongyouwantopause).

import io.reactivex.rxjava3.core.Observable;

import java.util.concurrent.TimeUnit;

public class IntervalOperator {
    public static void main(String[] args) throws InterruptedException {
        Observable<Long> clock = Observable.interval(1000, TimeUnit.MILLISECONDS);
        clock.subscribe(System.out::println, System.out::println,
                () -> System.out.println("done"));

       Thread.sleep(5000);

    }
}

2.if dont want to pasure thread for some time, i have to continuously.
  you have to use blockingXXX api

package com.del.reactive.core.create;

import io.reactivex.rxjava3.core.Observable;

import java.util.concurrent.TimeUnit;

public class IntervalOperator {
    public static void main(String[] args) throws InterruptedException {
        Observable<Long> clock = Observable.interval(1000, TimeUnit.MILLISECONDS);
//        clock.subscribe(System.out::println, System.out::println,
//                () -> System.out.println("done"));

     //  Thread.sleep(5000);
        clock.blockingSubscribe(System.out::println, System.out::println,
                () -> System.out.println("done"));

    }
}
...............................................................................................					Subscription and UnSubscription
.............................................................................................

Producer and Consumers are connected by calling subscribe method.

if i want to unsubcribe, or if i want to terminate relationship with producer, then you can dispose.
once disposed , data will not be emitted.

package com.del.reactive.core.create;

import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.disposables.Disposable;

import java.util.concurrent.TimeUnit;

public class DisposingSubscriber {
    public static void main(String[] args) throws InterruptedException {
        Observable<Long> clock = Observable.interval(1000, TimeUnit.MILLISECONDS);
        Disposable disposable = clock.subscribe(System.out::println, System.out::println,
                () -> System.out.println("done"));
        disposable.dispose();
        Thread.sleep(10000);

    }

}
..............................................................................................
				Life Cycle apis and lazy evaluation
..............................................................................................

Producer never emits data until subscription - until subscribe is called.

package com.del.reactive.core.create;

import io.reactivex.rxjava3.core.Observable;

public class LazySubscription {
    public static void main(String[] args) {
        Observable<String> stream = Observable.create(observer -> {
            System.out.println("Inside stream");
            observer.onNext("Hello");
        });
        System.out.println("Stream is ready to consume");
        //once subscribe is called only data emission starts
        stream.subscribe(System.out::println);
    }
}
.............................................................................................

Function Composition,pure Function,Immutablity:
...............................................
Observable o1=fun1() (operator1)
Observable o2=o1.fun2()

chaining
fun1().fun2()

package com.del.reactive.core.create;

import io.reactivex.rxjava3.core.Observable;

public class LifeCycleApi {
    public static void main(String[] args) {
        Observable.create(observer -> {
            System.out.println("Inside stream");
            observer.onNext("Hello");
            observer.onComplete();
        }).doOnSubscribe(consumer -> {
            System.out.println("init");
        }).doOnNext(data -> {
            System.out.println("Got Data : " + data);
        }).doOnError(err -> {
            System.out.println("Got Error" + err);
        }).doOnComplete(() -> {
            System.out.println("done!");
        }).subscribe();
    }
}
.............................................................................................
				How to observe Stream using operators
				     (Data Processing)

.............................................................................................

Pointers:

->Every operator is pure function, which returns new immutable (Observable),composable.
->Should compose on single workflow

Category:

1.Transforming Observables

 if you want to change data from one state to another state.


RXJAVA Transformation Operators

buffer
cast
concatMap
concatMapCompletable
concatMapCompletableDelayError
concatMapDelayError
concatMapEager
concatMapEagerDelayError
concatMapIterable
concatMapMaybe
concatMapMaybeDelayError
concatMapSingle
concatMapSingleDelayError
flatMap
flatMapCompletable
flatMapIterable
flatMapMaybe
flatMapObservable
flatMapPublisher
flatMapSingle
flatMapSingleElement
flattenAsFlowable
flattenAsObservable
groupBy
map
scan
switchMap
window
buffer


2.Filtering Observables
 
Works against Predicate (boolean )expression

debounce
distinct
distinctUntilChanged
elementAt
elementAtOrError
filter
first
firstElement
firstOrError
ignoreElement
ignoreElements
last
lastElement
lastOrError
ofType
sample
skip
skipLast
take
takeLast
throttleFirst
throttleLast
throttleLatest
throttleWithTimeout
timeout

Combining Observables
Operators that work with multiple source Observables to create a single Observable

combineLatest
join and groupJoin
merge
mergeDelayError
rxjava-joins
startWith
switchOnNext
zip

Error Handling Operators
........................
  Operators that help to recover from error notifications from an Observable

doOnError
onErrorComplete
onErrorResumeNext
onErrorReturn
onErrorReturnItem
onExceptionResumeNext
retry
retryUntil
retryWhen
...........
Utitlites Operators

materialize( ) — convert an Observable into a list of Notifications
dematerialize( ) — convert a materialized Observable back into its non-materialized form
timestamp( ) — attach a timestamp to every item emitted by an Observable
serialize( ) — force an Observable to make serialized calls and to be well-behaved
cache( ) — remember the sequence of items emitted by the Observable and emit the same sequence to future Subscribers
observeOn( ) — specify on which Scheduler a Subscriber should observe the Observable
subscribeOn( ) — specify which Scheduler an Observable should use when its subscription is invoked
doOnEach( ) — register an action to take whenever an Observable emits an item
doOnNext( ) — register an action to call just before the Observable passes an onNext event along to its downstream
doAfterNext( ) — register an action to call after the Observable has passed an onNext event along to its downstream
doOnCompleted( ) — register an action to take when an Observable completes successfully
doOnError( ) — register an action to take when an Observable completes with an error
doOnTerminate( ) — register an action to call just before an Observable terminates, either successfully or with an error
doAfterTerminate( ) — register an action to call just after an Observable terminated, either successfully or with an error
doOnSubscribe( ) — register an action to take when an observer subscribes to an Observable
1.x doOnUnsubscribe( ) — register an action to take when an observer unsubscribes from an Observable
finallyDo( ) — register an action to take when an Observable completes
doFinally( ) — register an action to call when an Observable terminates or it gets disposed
delay( ) — shift the emissions from an Observable forward in time by a specified amount
delaySubscription( ) — hold an Subscriber's subscription request for a specified amount of time before passing it on to the source Observable
timeInterval( ) — emit the time lapsed between consecutive emissions of a source Observable
using( ) — create a disposable resource that has the same lifespan as an Observable
single( ) — if the Observable completes after emitting a single item, return that item, otherwise throw an exception
singleOrDefault( ) — if the Observable completes after emitting a single item, return that item, otherwise return a default item
repeat( ) — create an Observable that emits a particular item or sequence of items repeatedly
repeatWhen( ) — create an Observable that emits a particular item or sequence of items repeatedly, depending on the emissions of a second Observable

Conditional and Boolean Operators
................................

amb
defaultIfEmpty
skipUntil
skipWhile
takeUntil
takeWhile

Mathematical and Aggregate Operators
....................................

Mathematical Operators
averageDouble
averageFloat
max
min
sumDouble
sumFloat
sumInt
sumLong
Standard Aggregate Operators
count
reduce
reduceWith
collect
collectInto
toList
toSortedList
toMap
toMultimap

Backpressure Operators:
.......................
  Reactive Streams

Connectable Observable Operators:

Multi casting: Subjects
...............
ConnectableObservable.connect( ) — instructs a Connectable Observable to begin emitting items
Observable.publish( ) — represents an Observable as a Connectable Observable
Observable.replay( ) — ensures that all Subscribers see the same sequence of emitted items, even if they subscribe after the Observable begins emitting the items
ConnectableObservable.refCount( ) — makes a Connectable Observable behave like an ordinary Observable
..............................................................................................

					Types of streams

1.Up Stream
2.Down Stream

 if you want to understand this concept, Assembly Line Analogy:

    Reactive Programs are thought as conveyor belt and work stations. The raw material pours from a source and ends up as fininished product ready to be pushed to the consumer.

    work stations are implemented by Reactive Operators(methods), are connected via Stream Objects(Observable)

............................................................................................

Transformation:

1.map
 map operator is called for every item emitted from source/up stream.

package com.del.reactive.operators.transformation;

import io.reactivex.rxjava3.core.Observable;

public class MapOperator {
    public static void main(String[] args) {
        Observable<Integer> stream = Observable.range(1, 10)
                .map(i -> {
                    System.out.println("map is called for up Stream  " + i);
                    return i * 2; //logic to double the number
                })
                .map(j -> {
                    System.out.println("map is called for downstream " + j);
                    return j * 2;
                });

        stream.subscribe(System.out::println);
    }
}
.............................................................................................
buffer:
map emits each and every value to the downstream.
if i want to emit batch by batch, lets say 2 values 
Collects the items emitted by a reactive source into buffers, and emits these buffers.

package com.del.reactive.operators.transformation;

import io.reactivex.rxjava3.annotations.NonNull;
import io.reactivex.rxjava3.core.Observable;

import java.util.List;

public class BufferOperator {
    public static void main(String[] args) {
        Observable<List<Integer>> stream = Observable.range(1, 10)
                .map(i -> {
                    System.out.println("map is called for up Stream  " + i);
                    return i * 2; //logic to double the number
                })
                .map(j -> {
                    System.out.println("map is called for downstream " + j);
                    return j * 2;
                })
                .buffer(3);
        stream.subscribe(System.out::println);
    }
}
.............................................................................................

flatMap:
.......
 
 Nested Arrays / Nested DataStructure.
flatting processing, converting nested into a single source.

map vs flatMap:

map is used to transform and return a data.

flatMap is used to transform and flatten inner observable.
package com.del.reactive.operators.transformation;

import io.reactivex.rxjava3.core.Observable;

public class FlatMapOperator {
    public static void main(String[] args) {
        Observable.just("A", "B", "C")
                .map(String::toLowerCase)
                .subscribe(
                        System.out::println, System.out::println, () -> {
                            System.out.println("done");
                        }
                );
        //flat map. i want to return [1,2,3] for each item
        Observable.just("A", "B", "C")
                .flatMap(i -> {
                    System.out.println("item " + i);
                    return Observable.just(1, 2, 3);
                })
                .subscribe(
                        System.out::println, System.out::println, () -> {
                            System.out.println("done");
                        }
                );
    }
}
............................................................................................
concatMap:
Applies the given io.reactivex.functions.Function to each item emitted by a reactive source, where that function returns a reactive source, and emits the items that result from concatenating the results of these function applications.

package com.del.reactive.operators.transformation;

import io.reactivex.rxjava3.core.Observable;

import java.util.concurrent.TimeUnit;

public class ConcatMapOperator {
    public static void main(String[] args) {
        Observable.range(1, 5)
                .concatMap(i -> {
                    return Observable.just("A").map(n -> n + " " +  i);
                })
                .blockingSubscribe(System.out::print);

// prints 01234

    }
}
.............................................................................................
package com.del.reactive.operators.filters;

import io.reactivex.rxjava3.core.Observable;

public class FilterOperator {
    public static void main(String[] args) {
        Observable<Integer> stream = Observable.range(1, 100)
                .filter(i -> {
                    System.out.println("I value" + i);
                    return i % 2 == 0;
                })
                .map(j -> {
                    System.out.println("Map j " + j);
                    return j;
                });
        stream.subscribe(System.out::println);
        //even numbers

    }
}
..............................................................................................

Coimbining Streams:
..................
package com.del.reactive.operators.coimbine;

import io.reactivex.rxjava3.core.Observable;

public class ComibingStreams {
    public static void main(String[] args) {
        Observable<Integer> intStream = Observable.just(1, 2, 3, 4);
        Observable<String> stringStream = Observable.just("a", "b", "c", "d", "e");

        //coimbine
        Observable.zip(intStream, stringStream, (i, j) -> {
            String result = i + j;
            return result;
        }).subscribe(System.out::println);
    }
}
///////////////////////////////////////////////////////////////////////////////////////////

merging:
Combines multiple Observables into one. Any onError notifications passed from any of the source observables will immediately be passed through to through to the observers and will terminate the merged Observable.

package com.del.reactive.operators.coimbine;

import io.reactivex.rxjava3.core.Observable;

public class MergeOperator {
    public static void main(String[] args) {
        Observable.just(1, 2, 3)
                .mergeWith(Observable.just(4, 5, 6))
                .subscribe(item -> System.out.println(item));

// prints 1, 2, 3, 4, 5, 6

    }
}
..............................................................................................
Math Operators:

 Math operators are not part of core Rxjava api, rather 

Mathe operators are part of the RxJava2Extensions project. 
You have to add the rxjava2-extensions module as a dependency to your project.
It can be found at http://search.maven.org.


Add maven dependancy
    <dependency>
            <groupId>com.github.akarnokd</groupId>
            <artifactId>rxjava3-extensions</artifactId>
            <version>3.0.1</version>
        </dependency>

package com.del.reactive.operators.math;

import hu.akarnokd.rxjava3.math.MathObservable;
import io.reactivex.rxjava3.core.Observable;

public class MathOperators {
    public static void main(String[] args) {
        //sum
        Observable<Integer> numbers = Observable.range(1, 100);
        MathObservable.sumInt(numbers).subscribe(System.out::println);
        MathObservable.min(numbers).subscribe(System.out::println);
        MathObservable.max(numbers).subscribe(System.out::println);

    }
}
.............................................................................................
				Broad Casting
...............................................................................................

Producer(Stream)-----can be connected with ---one Subscriber : 
one to one  This communication style is called "unicast".

Producer(Stream)----can be connected with ----->many subscribers : 
one to Many  This communication style is called "Multicast".


Based on this communication style stream can be classified into two category.

1.Cold Observable(Cold Stream)
2.Hot Observable(Hot Stream)



1.Cold Observable

1.Observable that doesn’t emit items until a subscriber subscribes.

2.If we have more than one subscriber, then observable will emit sequence of items to all subscribers one by one. : cold

3.Each subscriber get fresh copy of the data from the begining.

4.Most of Observerables are Cold.

package com.del.reactive.operators.multicast.obs;

import io.reactivex.rxjava3.core.Observable;

import java.util.concurrent.TimeUnit;

public class ColdStream {
    public static void main(String[] args) throws InterruptedException {
        //one publisher to many subscriber; using cold stream.
        Observable<Long> myObservable = Observable.interval(1, TimeUnit.SECONDS);
        //the 1st subscriber
        myObservable.subscribe(item -> System.out.println("Subscriber 1: " + item));
        Thread.sleep(3000);
        myObservable
                .doOnSubscribe((r) -> System.out.println("Subscriber 2 Joining"))
                .doOnNext(item -> System.out.println("Subscriber 2: " + item))
                //.subscribe();
                .blockingLast();

        //Thread.sleep(5000);

    }
}
.............................................................................................

Cold Stream with unsubscription:



package com.del.reactive.operators.multicast.obs;

import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.disposables.Disposable;

import java.util.concurrent.TimeUnit;

public class ColdStreamWithUnSubscription {
    public static void main(String[] args) throws InterruptedException {
        //one to many ; cold stream;
        Observable<Long> myObservable = Observable.interval(1, TimeUnit.SECONDS);
        myObservable.subscribe(item -> System.out.println("Subscriber 1: " + item));
        //after 3scs new subscriber joins
        Thread.sleep(3000);
        //unsubscription handle
        Disposable subscriber2 = myObservable
                .doOnSubscribe((r) -> System.out.println("Subscriber 2 Joining"))
                .doFinally(() -> System.out.println("Subscriber 2 left"))
                .subscribe(item -> System.out.println("Subscriber 2: " + item));
        Thread.sleep(5000);
        subscriber2.dispose();
        Thread.sleep(8000);
    }
}
................................................................................................

Hot Observable:

1.Observables that don’t wait for any subscription. They start emitting items   when created.
2.They don’t emit the sequence of items again for a new subscriber.

3.When an item is emitted by hot observable, all the subscribers that are   subscribed will get the emitted item at once.

There are many ways to implement hot observables:

1.ConnectableObservable
2.Subjects

1.ConnectableObservable:
 Used to convert cold stream into hot stream

A ConnectableObservable is a single observable source for different observers.
The main difference aside from being a single observable source is that calling subscribe on a ConnectableObserver will not trigger emission, but connect will.

package com.del.reactive.operators.multicast.obs;

import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.disposables.Disposable;
import io.reactivex.rxjava3.observables.ConnectableObservable;

import java.util.concurrent.TimeUnit;

public class HotStream {
    public static void main(String[] args) throws InterruptedException {
        //cold stream
        Observable<Long> myObservable = Observable.interval(1, TimeUnit.SECONDS);
        //convert cold into hot
        ConnectableObservable<Long> connectableObservable = myObservable.publish();
        //try to connect all subscribers under one single unit.
        connectableObservable.connect();

//immediate joining
        connectableObservable
                .doOnSubscribe((r) -> System.out.println("Subscriber 1 Joining"))
                .subscribe(item -> System.out.println("Subscriber 1: " + item));
        Thread.sleep(3000);

        Disposable subscriber2 = connectableObservable
                .doOnSubscribe((r) -> System.out.println("Subscriber 2 Joining"))
                .doOnDispose(() -> System.out.println("Subscriber left session"))
                .subscribe(item -> System.out.println("Subscriber 2: " + item));

        Thread.sleep(3500);

        subscriber2.dispose();

        connectableObservable
                .doOnSubscribe((r) -> System.out.println("Subscriber 3 Joining"))
                .subscribe(item -> System.out.println("Subscriber 3: " + item));

        Thread.sleep(8000);


    }
}
/////////////////////////////////////////////////////////////////////////////////////////////
				Subjects
.............................................................................................

 Subject a “hot” Observable variant of the original “cold” Observable

Varieties of Subject:

1.AsyncSubject 

It emits the last value (and only the last value) emitted by the source Observable, and only after that source Observable completes.

(If the source Observable does not emit any values, the AsyncSubject also completes without emitting any values.)

package com.del.reactive.operators.multicast.subjects;

import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.subjects.AsyncSubject;

public class HotAsyncSubject {
    public static void main(String[] args) {

        Observable<Integer> sourceStream = Observable.create(subscriber -> {
            for (int i = 0; i <= 20; i++) {
                subscriber.onNext(i);
            }
           subscriber.onComplete();
        });
//        Observable<Integer> sourceStream = Observable.just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        //Create Async Subject
        AsyncSubject<Integer> asyncSubject = AsyncSubject.create();
        //connect source stream with async subject
        sourceStream.subscribe(asyncSubject);

        asyncSubject.subscribe(data -> {
            System.out.println("Subu's AsyncSubject Subject :" + data);
        }, err -> {
            System.out.println(err);
        }, () -> {
            System.out.println("Done!");
        });
        asyncSubject.subscribe(data -> {
            System.out.println("Ram's AsyncSubject Subject :" + data);
        }, err -> {
            System.out.println(err);
        }, () -> {
            System.out.println("Done!");
        });
    }
}
.............................................................................................
BehaviorSubject:


-When an observer subscribes to a BehaviorSubject, it begins by emitting the item most recently emitted by the source Observable (or a seed/default value if none has yet been emitted) and then continues to emit any other items emitted later by the source Observable(s).

 BehaviourSubject emits the most recently item at the time of subscription or
 a default item if none has been emitted and then continues the sequence until complete.

package com.del.reactive.operators.multicast.subjects;

import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.subjects.BehaviorSubject;

import java.util.concurrent.TimeUnit;

public class HotBehvaiourSubject {
    public static void main(String[] args) throws InterruptedException {
        //soure stream
      //  Observable<Long> sourceStream = Observable.interval(1000, TimeUnit.MILLISECONDS);
        
        //This will emit default value
        Observable sourceStream = Observable.create(observer->{

        });
        //create Behaviour Subject
        BehaviorSubject<Long> behaviorSubject = BehaviorSubject.createDefault(0l);
        //connecting source stream with Behaviour
        sourceStream.subscribe(behaviorSubject);

        System.out.println("Wait for some seconds");
        Thread.sleep(10000);
        // BehaviourSubject emits the most recently item at the time of subscription
        behaviorSubject.subscribe(data -> {
            System.out.println("Subu's BehaviorSubject Subject :" + data);
        }, err -> {
            System.out.println(err);
        }, () -> {
            System.out.println("Done!");
        });

        behaviorSubject.subscribe(data -> {
            System.out.println("Ram's BehaviorSubject Subject :" + data);
        }, err -> {
            System.out.println(err);
        }, () -> {
            System.out.println("Done!");
        });
        System.out.println("Wait for some seconds");
        Thread.sleep(10000);
    }
}
............................................................................................
			         RxJava Streo Types
.............................................................................................
Streo types :
 Bean
   -Component,Service,Repository,Controller

Rx java Streo Types:
...................
Observable - o---n 
Single - only item
Maybe - single or empty
Completeable - only complete


Single:
......
RxJava (and its derivatives like RxGroovy & RxScala) has developed an Observable variant called “Single.”

A Single is something like an Observable, but instead of emitting a series of values — anywhere from none at all to an infinite number — it always either emits one value or an error notification.

package com.del.reactive.core.sterotypes;

import io.reactivex.rxjava3.core.Single;

public class SingleType {
    public static void main(String[] args) {
        Single.create(emitter -> {
            emitter.onSuccess("Hello");
        }).subscribe(System.out::println);

        Single.create(emitter -> {
            emitter.onError(new RuntimeException("error"));
        }) .subscribe(System.out::println, System.out::println);

        Single.just(1).subscribe(System.out::println);

       // Single.just(1,2,3).subscribe(System.out::println);

    }
}

Maybe:

Maybe is similar to Single . but special Singles

only item: Maybe.just
only completed single: Maybe.empty
only error : Maybe.error

package com.del.reactive.core.sterotypes;

import io.reactivex.rxjava3.core.Maybe;

public class MayBeType {
    public static void main(String[] args) {
        //only item
        Maybe.just(1).subscribe(System.out::println);
        //only error
        Maybe.error(new RuntimeException("error")).subscribe(System.out::println, System.out::println);
        //only complete
        Maybe.empty().subscribe(System.out::println, System.out::println, () -> System.out.println("onComplete"));
    }
}
............................................................................................

Completeable: only completesignal

package com.del.reactive.core.sterotypes;

import io.reactivex.rxjava3.core.Completable;

public class CompleteableType {
    public static void main(String[] args) {
        Completable.complete().subscribe(() -> System.out.println("Completeable"));
    }
}
............................................................................................
					Reactive Streams
.............................................................................................

What is reactive Stream?

It is standard for java echo systems to reactive libs/frameworks/apis
Reactive Streams is an initiative to provide a standard for asynchronous stream processing with non-blocking back pressure.

Asynch Streaming + Back Pressure.

Back Pressure:

Upstream is faster enough to stream data to downstream , where downstream is unable to process data.
   -Back Pressure.

When back pressure happens , 
  -data loss
  -data inconsisistency

How to handle back pressure?

How to manage backpressure?
we have various patterns

Rxjava 1.x 
 -Through backpressure operators
Buffer
Sample
Debounce
Window
filter
.....

backpressure operators
 strategies for coping with Observables that produce items more rapidly than their observers consume them


1.Via Operators:

Most of the Flitering Operators are back pressure managed operators
 debounce,distinct,ElementAt,filter,first,ignoreElements,Last,sample,skip,skipLast,take,takeLast.

During backpressure, items may be droped
 drop operators: fliter
 collecting operators: window,buffer

2.Reactive Pull
..............
Above two strategies manage backpressure by dropping items, if your application need to process all the items emitted by source observable then you can’t use those strategies.

In this scenario, using reactive pull strategy is the right choice. In reactive pull, subscriber requests required number of items from observable by calling request().


Reactive Pull:

 Reactive programs supports push paradigm
 Reactive programs supports even pull also


PUSH + PULL = Reactive PULL

Down Stream can control up stream with help of mediator object that is called
"Subscription object"

DownStream --------Subscription ---------UpStream

DownStream --------Subscription ---------UpStream
                        |
                 request(no-elements)


Reactive Streams:
.................
   Reactive Stream is spec published to enable backpressure and create Back Pressure streams.-https://www.reactive-streams.org/

How provide backPressure handling feature at api level or Publisher level?

Soultion : Publisher level, in order to provide publisher , Many companies joined together

who published another spec "Reactive Stream"

Reactive Streams is an initiative to provide a standard for asynchronous stream processing with non-blocking back pressure. This encompasses efforts aimed at runtime environments (JVM and JavaScript) as well as network protocols.


The Team provided common spec:

1.Publisher
2.Subscriber
3.Subscription
4.Processor

After this spec published, Rxjava team relased new version - Rxjava 2 which implements reactive stream specification..

Rxjava 1 - has no implementation of "Reactive Stream Spec"

Rxjava 2 - Reactive Stream Spec implemented.

Rxjava 2 Provided one Simple Observable.

Flowable ====== Observable

Flowable vs Observable

Flowable 
  emits 0...n items
  backpressure ready streams
  implements reactive stream spec

Observable
  emits 0..n items
  no backpressure
  no reactive stream stream spec.

/////

BackPressure handling Operators:
.................................

package com.del.reactive.reactivestreams;

import io.reactivex.rxjava3.core.Observable;

import java.util.concurrent.TimeUnit;

public class BackPressureOperators {
    public static void main(String[] args) throws InterruptedException {
        //sampleOpertor();
       // buffer();
        lastN();
    }

    public static void sampleOpertor() throws InterruptedException {
        Observable<Integer> observable = Observable
                .range(1, 5000)
                .sample(1, TimeUnit.NANOSECONDS) //back pressure operator
                .map(i -> i); //down stream dont get values from 1 rather
        observable.subscribe(s -> {
            System.out.println("value after every 1 nano secs " + s);
        });

         Thread.sleep(10000);
    }
    public static void buffer() {
        Observable.range(1, 2000)
                .buffer(5) //back pressure operator , buffering/storing values and send to down stream
                .map(i -> i) //down stream dont get values from 1 rather than get buffer of 5
                .subscribe((i) -> System.out.println("Item Got :" + i), System.out::println);
    }
    public static void lastN() {
        Observable.range(1, 100)
                .takeLast(50) //back pressure drop all items , expect last 50 values
                .map(i -> i) //down stream dont get values from 1 to 50,
                .subscribe((i) -> System.out.println("Item Got :" + i), System.out::println);
    }
}
...............................................................................................


Flowable and Backpressure Handling: Reactive Stream Implementation:

package com.del.reactive.reactivestreams;

import io.reactivex.rxjava3.core.Flowable;
import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.schedulers.Schedulers;

public class FlowableBackPressure {
    static void sleep(long milliseconds) {
        try {
            Thread.sleep(milliseconds);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        Flowable.range(1, 999_999_999)
                .map(MyItem::new) //upstream is fast enough to send data
                .observeOn(Schedulers.io())
                .subscribe(myItem -> {
                    sleep(500); //down stream/subscriber are slow
                    System.out.println("Received MyItem " +
                            myItem.id);
                });
        sleep(Long.MAX_VALUE);
    }

    static final class MyItem {
        final int id;

        MyItem(int id) {
            this.id = id;
            System.out.println("Consuming myitem " + id);
        }
    }
}
...............................................................................................

Flowable has all operators:

Flowable.just,Flowable.fromArray......
..............................................................................................
                 			Concurrency 
.............................................................................................

Streaming  -  data flow
Processing  - Stream processing if want to schdule concurrently - Async

Rxjava Async Stream processing  done via Schedulers

If you want to introduce multithreading into your cascade of Observable operators, you can do so by instructing those operators (or particular Observables) to operate on particular Schedulers.


How to implement conncurrency in reactive programming?

-Multithreading.

how do i implement multithreading?

->Thread and Runnable.

->Executor framework- abstraction  for multithreading.

->Reactive extension introduced functional style multithreading framework

Schedulers.

 It is a framework provided by reactive programming

Rxjava and Schedulers


Schedulers can help  isloate streaming processing into a separate thread of execution

Schedulers:
...........
A scheduler is low level thread abstraction similar to "ExecutorService" in java.

Scheduler has wide range of features
- virutal time for testing
- trampoling for immediate scheduling
so on...

Rxjava threads can be created in many ways: Types of threads


The Schedulers class has static methods that give access to the following execution contexts:

The current thread (Schedulers.immediate()).

A single, reusable thread (Schedulers.single()).
 Note that this method reuses the same thread for all callers, until the Scheduler is disposed. If you want a per-call dedicated thread, use Schedulers.newSingle() for each call.


An elastic thread pool (Schedulers.elastic()). 

It creates new worker pools as needed, and reuse idle ones.
 Worker pools that stay idle for too long (default is 60s) are disposed. This is a good choice for I/O blocking work for instance. Schedulers.elastic() is a handy way to give a blocking process its own thread, so that it does not tie up other resources.

a fixed pool of workers that is tuned for parallel work (Schedulers.parallel()). It creates as many workers as you have CPU cores

An uses non blocking io threads (Schedulers.io()). 


How to run operators in a separate thread of execution?

observeOn(s):
 where you have attached this operator in the middle of subscriber chain, it takes signals from the upstream and replays them downstream while executing the task from the associated scheduler.

will apply thread to the down stream.

subscribeOn
 applies to the subscription process,
 no mater where you place the subscribeOn in the chain.
 It always affects context of the source emission.

package com.del.reactive.concurency;

import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.schedulers.Schedulers;

public class MultiThreadedStreamProcesing {
    public static void processObserveOn(){
        Observable.range(1, 5)
                .observeOn(Schedulers.single())
                .map(i -> {
                    System.out.println("map 1 " + Thread.currentThread().getName());
                    return i * 2;
                })
                .observeOn(Schedulers.computation())
                .map(i -> {
                    System.out.println("map 2 " + Thread.currentThread().getName());
                    return i * 2;
                })
                .observeOn(Schedulers.newThread())
                .map(i -> {
                    System.out.println("map 3 " + Thread.currentThread().getName());
                    return i * 3;
                })
                .subscribe();
        try {
            Thread.sleep(5000);
        } catch (InterruptedException exception) {
            exception.printStackTrace();
        }
    }

    public static void subscribeOn() {
        Observable.range(1, 5)
                .map(i -> {
                    System.out.println("map 1 " + Thread.currentThread().getName());
                    return i * 2;
                })
                .observeOn(Schedulers.newThread())
                .map(i -> {
                    System.out.println("map 2 " + Thread.currentThread().getName());
                    return i * 2;
                })
               .subscribeOn(Schedulers.computation())
                .map(i -> {
                    System.out.println("map 3 " + Thread.currentThread().getName());
                    return i * 3;
                })
                .subscribe(data->{
                    System.out.println("Inside subcribe method " + Thread.currentThread().getName());
                });
        try {
            Thread.sleep(5000);
        } catch (InterruptedException exception) {
            exception.printStackTrace();
        }
    }
    public static void main(String[] args) {
     subscribeOn();
    }
}




observeOn and subscribeOn:
...........................
package com.del.reactive.concurency;

import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.schedulers.Schedulers;

public class MultiThreadedStreamProcesing {
    public static void processObserveOn(){
        Observable.range(1, 5)
                .observeOn(Schedulers.single())
                .map(i -> {
                    System.out.println("map 1 " + Thread.currentThread().getName());
                    return i * 2;
                })
                .observeOn(Schedulers.computation())
                .map(i -> {
                    System.out.println("map 2 " + Thread.currentThread().getName());
                    return i * 2;
                })
                .observeOn(Schedulers.newThread())
                .map(i -> {
                    System.out.println("map 3 " + Thread.currentThread().getName());
                    return i * 3;
                })
                .subscribe();
        try {
            Thread.sleep(5000);
        } catch (InterruptedException exception) {
            exception.printStackTrace();
        }
    }

    public static void subscribeOn() {
        Observable.range(1, 5)
                .map(i -> {
                    System.out.println("map 1 " + Thread.currentThread().getName());
                    return i * 2;
                })
                .observeOn(Schedulers.newThread())
                .map(i -> {
                    System.out.println("map 2 " + Thread.currentThread().getName());
                    return i * 2;
                })
               .subscribeOn(Schedulers.computation())
                .map(i -> {
                    System.out.println("map 3 " + Thread.currentThread().getName());
                    return i * 3;
                })
                .subscribe(data->{
                    System.out.println("Inside subcribe method " + Thread.currentThread().getName());
                });
        try {
            Thread.sleep(5000);
        } catch (InterruptedException exception) {
            exception.printStackTrace();
        }
    }
    public static void main(String[] args) {
     subscribeOn();
    }
}
..............................................................................................
				Rxjava with other libs and frameworks
.............................................................................................

The process of attaching rxjava lib to other frameworks called "rxficattion".

Vertx is reactive toolkit to build non blocking and reactive microservices.

Vertx itself provides wrapper on top rxjava -  rxifixed apis.

eg:
  if i want to create http application with reactive
  
  HTTP api + reactive api => ReactiveHTTP API
..............................................................................................
			














